# Last Version pyinstaller
# pyinstaller --onedir --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --hidden-import=sklearn.ensemble._forest --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis_3\.venv\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis3\crewai\translations\en.json;crewai/translations" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis3\best_random_forest_model.joblib;." main.py


# seq_key = 412931
# # 469085  400965 # Aporva com justificativa de Custos
# #412931    # Aprova com Justificativa da Fabrica
# #469085  #405019 #469085  # Substitua pelo número da ordem real 405019
# 443254 variaçao IM X IC


# Reinstala todas as dependencias
# pip install -r requirements.txt

# Limpa Diretórios com algum lixo de instalação
# pyinstaller --clean --onefile --name AI_WO_Approval --collect-all embedchain main.py

# pip freeze > requirements.txt
# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --additional-hooks-dir=. main.py
# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --add-data "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" main.py
# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --add-data "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" --add-data "translations;translations" main.py


# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --add-data "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" --add-data "crewai/translations;crewai/translations" main.py

# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --add-data "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" --add-data "crewai/translations\en.json;translations/en.json" main.py

# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\crewai\translations\en.json;crewai/translations/en.json" --add-data "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" main.py


# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\crewai\translations\en.json;crewai/translations" --add-data "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" main.py

# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --hidden-import=sklearn.ensemble._forest --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\crewai\translations\en.json;crewai/translations" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\best_random_forest_model.joblib;." main.py

# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --hidden-import=sklearn.ensemble._forest --add-data "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\crewai\translations\en.json;crewai/translations" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\best_random_forest_model.joblib;." main.py

# pyinstaller --onefile --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --hidden-import=sklearn.ensemble._forest --add-data "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\crewai\translations\en.json;crewai/translations" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\crewai\translations\slices.json;crewai/translations" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\crewai\translations\role_playing.json;crewai/translations" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\best_random_forest_model.joblib;." main.py

# PS C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\dist> .\AI_WO_Approval.exe 412931  "Tivemos um aumento do custo real devido a uma maior utilização das horas de execução de máquina. Tivemos que utilizar a máquina por mais tempo que o previsto."
# C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\crewai\utilities

# .\AI_WO_Approval.exe 412931  "Tivemos um aumento do custo real devido a uma maior utilização das horas de execução de máquina. Tivemos que utilizar a máquina por mais tempo que o previsto."

# pyinstaller - -onefile - -name
# AI_WO_Approval - -hidden -
# import=embedchain - -hidden -
# import=importlib_metadata - -hidden -
# import=sklearn.ensemble._forest - -add - data
# "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" - -add - data
# "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\crewai\translations\en.json;crewai/translations" - -add - data
# "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\best_random_forest_model.joblib;."
# main.py

# atualizar o requirements
# pip freeze > requirements.txt
# Visualizar a arvore de diretorios das dependencia
# # pipdeptree

# 412931 "Tivemos um aumento do custo real devido a uma maior utilizaçao das horas de execuçao de maquina. Tivemos que utilizar a maquina por mais tempo que o previsto"

# PS C:\Users\ccerq\OneDrive\Documentos\Python Scripts\WebApprovalWo\WebApprovalWo> python app.py
# PS C:\Users\ccerq\OneDrive\Documentos\Python Scripts\WebApprovalWo\web-frontend> npm start

# git init
# git add *
# git commit -m "commit inicial14_11"
# git remote add origin https://github.com/ccerquei2/ML_CostAnalysis_one.git
# git branch -M main11
# git push -u origin main11
#

# git init
# git add *
# git commit -m "commit encrypt"
# git remote add origin https://github.com/ccerquei2/WOApprovalbyAI.git
# ou
# git remote set-url origin https://github.com/ccerquei2/WOApprovalbyAI.git
# git branch -M main
# git push -u origin main

# C:\Users\ccerq\OneDrive\Documentos\Python Scripts\AIGroqAgente
# Remove-Item -Recurse -Force .git
# git init
# git add *
# git commit -m "commit main6"
# git remote add origin https://github.com/ccerquei2/ML_CostAnalysis_one.git
# git remote add origin https://github.com/ccerquei2/WebApprovalWo.git
# git branch -M main6
# git push -u origin main6


# Geração do Executável com arquivos na pasta
# pyinstaller --onedir --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --hidden-import=sklearn.ensemble._forest --add-data "C:\Users\ccerq\Envs\pythonProject1\ML_CostAnalysis\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\crewai\translations\en.json;crewai/translations" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis\best_random_forest_model.joblib;." main.py

# Maquina Granado - Projeto ML_CostAnalysis3
# pyinstaller --onedir --name AI_WO_Approval --hidden-import=embedchain --hidden-import=importlib_metadata --hidden-import=sklearn.ensemble._forest --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis_3\.venv\Lib\site-packages\embedchain-0.1.110.dist-info;embedchain-0.1.110.dist-info" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis3\crewai\translations\en.json;crewai/translations" --add-data "C:\Users\ccerq\OneDrive\Documentos\Python Scripts\ML_CostAnalysis3\best_random_forest_model.joblib;." main.py

# 412931

# ############################################################################################
# # Avalia se Ordem Segue para aprovação
# # Ação	Descriçao_Ação
# # 0	Aprova com Justificativa Plausivel
# # 1	Não Aprovava: Limites fora da Faixa de Aceitação
# # 2	Aprovado Considerando que o Analista de Custo Aprovaria Ordem com tais Limites
# # 3	Não Aprovava: Limites fora da Faixa de Aceitação
# ############################################################################################

import argparse
import Agents_PipeLine
import pandas as pd
import Classify_WorkOrder
from dotenv import load_dotenv
load_dotenv()
import json
import os
from Appove_WO import ApproveWorkOrder
from Email import PrepareEmail
from aiwo_logger import DBLogger, new_execution, db_logged


import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="__init__")

# environment = 'prod'
environment = 'dev'

logger = DBLogger()
EXEC_ID = new_execution()

# def __init__(self, environment='dev'):

class Analise_WO:
    def buscar_justificativa_fabrica(self, SEQ_KEY):
        justificativas = pd.read_csv('C:/Users/ccerq/OneDrive/Documentos/Python Scripts/ML_CostAnalysis/Justificativa_Fabrica.csv', sep=';')
        print("Columns in the CSV file:", justificativas.columns)
        justificativa = justificativas[justificativas['SEQ_KEY'] == SEQ_KEY]
        if not justificativa.empty:
            return justificativa.iloc[0]['JUSTIFICATIVA']
        else:
            return None

@db_logged(step="LoadInputs", phase="Init")
def load_inputs(seq_key, ordem):
    classificaWo = Classify_WorkOrder.Analise()
    df = classificaWo.extrair_dados(seq_key, ordem)
    df_qtd = classificaWo.extrair_dados_qtd(seq_key, ordem)
    return classificaWo, df, df_qtd

def main(seq_key, ordem, justificativa, groq_model):
    logger.log(level="INFO", step="StartApproval", order=ordem, seq_key=seq_key,
               execution_id=EXEC_ID, phase="Init", message="Approval run started")

    classificaWo, df, df_qtd = load_inputs(seq_key, ordem)

    predicao = ''
    resultado = ''
    if df is not None:
        resultado = classificaWo.classificar_ordem(df, logger=logger, execution_id=EXEC_ID)
        predicao = resultado['Predicted_OUTCOME'].iloc[0]
        if predicao == 'APROVADO AUTOMATICAMENTE':
            predicao = 'APROVADO COM JUSTIFICATIVA SETOR CUSTOS'
        print(predicao)

    json_avalia_limites = []
    json_avalia_limites_str = ''

    json_avalia_limites_str = classificaWo.json_avalia_faixas_aprovacao(seq_key, ordem, predicao)
    json_avalia_limites = json.loads(json_avalia_limites_str)

    decisao_aprovar = (json_avalia_limites[0]["Acao"])

    print(decisao_aprovar)

    BSSVApprove = ApproveWorkOrder()

    if decisao_aprovar == 1 or decisao_aprovar == 3:
        print('Um ou mais valores extrapolaram os limites de aprovação via ''Agentes AI'', Segue detalhamento:\n', json_avalia_limites_str)
        try_approve = Agents_PipeLine.PipeLineCoastJustify(logger=logger, execution_id=EXEC_ID)
        try_approve.insert_approval_result(seq_key,
                                           float(json_avalia_limites[0]['ORDEM']),
                                           decisao_aprovar,
                                           'Um ou mais valores extrapolaram os limites de aprovação via Agentes AI',
                                           json_avalia_limites_str,
                                           'Decisão de Validação: Não Validado',
                                           '')

        generate_email = PrepareEmail()
        # text_email = generate_email.create_report_text(df_qtd, json_avalia_limites)
        text_email = generate_email.create_report_html(df_qtd, json_avalia_limites, 'erro_faixas')
        generate_email.send_email( f"Alerta: Ordem {int(ordem)} Excedeu os Limites de Aprovação Automática", text_email, "ccerquei2@gmail.com",
                                      "aprovacao_ordens@granadophebo.com.br")
        logger.log(level="INFO", step="FinalDecision", order=ordem, seq_key=seq_key,
                   execution_id=EXEC_ID, phase="Post-action", decision=str(decisao_aprovar),
                   message="Decision completed")
        # print(text_email)


    else:
        #############################################################################################################
        # Adicionar Tratamento Novo Ricardo Stoeterau:
        # Se Predição solicita Justificativa da Fabrica, fluxo deverá
        # Verificar se a variação está relacionada a  quantidade de materia prima ou quantidade de hora
        #############################################################################################################
        if predicao == 'REQUER JUSTIFICATIVA FABRICA':
            verifica_erro_qtd = []
            verifica_erro_qtd = classificaWo.justificativa_fabrica(seq_key, ordem)
            if verifica_erro_qtd is None or verifica_erro_qtd.empty:
                # Caso variações de Quantidade estejam abaixo das faixas para requerer a justificativa da fabrica
                # o fluxo deve ser direcionado para 'APROVADO COM JUSTIFICATIVA SETOR CUSTOS'
                predicao = 'APROVADO COM JUSTIFICATIVA SETOR CUSTOS'
                decisao_aprovar = -2



        if predicao == 'APROVADO COM JUSTIFICATIVA SETOR CUSTOS':
            try_approve = Agents_PipeLine.PipeLineCoastJustify(logger=logger, execution_id=EXEC_ID)
            # try_approve.cost_approval_decision(df, decisao_aprovar, json_avalia_limites_str)
            result =  try_approve.execute_with_retries2(df, '', decisao_aprovar, json_avalia_limites_str,None)

            if result[1] == 'Decisão de Validação: Validado':
                return_approve = BSSVApprove.ApproveOrderJDE(environment, df['ORDEM'].iloc[0])
                print(return_approve)

            logger.log(level="INFO", step="FinalDecision", order=ordem, seq_key=seq_key,
                       execution_id=EXEC_ID, phase="Post-action", decision=str(decisao_aprovar),
                       message="Decision completed")
            os._exit(1)

        else:

            if justificativa == None or justificativa == '':
                try_approve = Agents_PipeLine.PipeLineCoastJustify(logger=logger, execution_id=EXEC_ID)
                try_approve.insert_approval_result(seq_key,
                                                   float(json_avalia_limites[0]['ORDEM']),
                                                   decisao_aprovar,
                                                   'A analise da ordem requer uma Justificativa Plausivel da Fabrica para as Variações Observadas',
                                                   json_avalia_limites_str,
                                                   'Decisão de Validação: Não Validado',
                                                   '')
                print('A analise da ordem requer uma Justificativa Plausivel da Fabrica para as Variações Observadas')

                generate_email = PrepareEmail()
                # text_email = generate_email.create_report_text(df_qtd, json_avalia_limites)
                text_email = generate_email.create_report_html(df_qtd, json_avalia_limites, 'erro_fab')
                generate_email.send_email(f"Alerta: Ordem {int(ordem)} Necessita de Justificativa da Fabrica", text_email,
                                          "ccerquei2@gmail.com",
                                          "aprovacao_ordens@granadophebo.com.br")

                logger.log(level="INFO", step="FinalDecision", order=ordem, seq_key=seq_key,
                           execution_id=EXEC_ID, phase="Post-action", decision=str(decisao_aprovar),
                           message="Decision completed")
                os._exit(1)

            else:


                fab_justificativa = justificativa if justificativa else Analise_WO().buscar_justificativa_fabrica(seq_key)
                print(fab_justificativa)
                print(resultado)

                try_approve = Agents_PipeLine.PipeLineCoastJustify(logger=logger, execution_id=EXEC_ID)
                # try_approve.approval_decision(df, fab_justificativa, decisao_aprovar, json_avalia_limites_str)
                # try_approve.execute_with_retries2(df, fab_justificativa, decisao_aprovar, json_avalia_limites_str,
                #                                   groq_model)

                # try_approve.approval_decision_qtd(df_qtd, fab_justificativa, decisao_aprovar, 0, json_avalia_limites_str,
                #                                   groq_model)

                result = try_approve.execute_with_retries2(df_qtd, fab_justificativa, decisao_aprovar, json_avalia_limites_str, groq_model)
                # print(result[1])

                if result[1] == 'Decisão de Validação: Validado':
                    return_approve = BSSVApprove.ApproveOrderJDE(environment, df['ORDEM'].iloc[0])
                    print(return_approve)

                logger.log(level="INFO", step="FinalDecision", order=ordem, seq_key=seq_key,
                           execution_id=EXEC_ID, phase="Post-action", decision=str(decisao_aprovar),
                           message="Decision completed")
                os._exit(1)





if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Processar uma ordem de produção.')
    parser.add_argument('SEQ_KEY', type=int, help='O identificador da ordem de produção.')
    parser.add_argument('ORDEM', type=int, help='Numero da Ordem de Produção.')
    parser.add_argument('JUSTIFICATIVA', type=str, nargs='?', help='Justificativa para a diferença de custo da ordem.', default=None)
    parser.add_argument('GROQ_MODEL', type=str, nargs='?', help='Modelo Preferencial Groq.', default=None)

    args = parser.parse_args()
    main(args.SEQ_KEY, args.ORDEM, args.JUSTIFICATIVA, args.GROQ_MODEL)
